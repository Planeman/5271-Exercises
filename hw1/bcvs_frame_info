# If you map out the structure of a frame for a function put it here
# so others don't need to redo work.

# Notice, if an absolute address for a frame is different don't assume
# that is whay you need since changes to argv will change the offset
# for all frames.
#
# Instead, what we are really concerned with is the order and offset
# of data *relative* to the top of the frame or some other refernece
# point.

main (on entry)
===============
  saved eip - 0x...76C (As expected right above local variables)
  locals - 0x...768
    (In the order they are on the stack)
    &logfile  = 0x...74C (28 bytes from top)
    &i        = 0x...748 (32 bytes from top)
    &log      = 0x...648 (288 bytes from top)

    - To overflow log[] and rewrite the entire return pointer for main will take
      292 bytes at least

copyFile (onEntry)
==================
  For reference, the saved eip in main for this inspection of copyfile
  is the same as above (0x...76C). This is the location the eip is stored
  on the stack not its value.

  &arg - 0x...630
    - Note the argument to coypFile is a pointer to the actual string so printing out this address
      in gdb will just give you another address which holds the string

  saved eip (for copyFile) - 0x...62C
    - 28 bytes below last local variable for main's stack

   locals - 0x...628 (Right below the return address)
    &c            = 0x...61C
    &i            = 0x...618
    &pid          = 0x...60C
    &status       = 0x...608
    &user         = 0x...5F8
    &tempString   = 0x...5B0
    &sourcefile   = 0x...614
    &destfile     = 0x...610
    &chmodString  = 0x...5AB
    &src          = 0x...56B
    &dst          = 0x...52B

    - From the top of the locals to the bottom is 253 bytes (ie 0x...628 -> 0x...52B)
